"""
Multi-Agent Demo: Chains, Swarms, and Coordination

This demo showcases Open Agent Flow's multi-agent capabilities:
1. Individual agents with tools
2. Chains - sequential agent pipelines
3. Swarms - parallel execution with consensus

No API keys needed - uses MockProvider automatically!

Usage:
    python examples/multi_agent_demo.py
"""

import asyncio

from openagentflow import agent, tool
from openagentflow.core.chain import chain, ChainResult
from openagentflow.core.swarm import swarm, SwarmResult
from openagentflow.core.types import AgentStatus


# =============================================================================
# TOOLS
# =============================================================================

@tool
def research_topic(topic: str) -> dict:
    """Research a topic and return key facts."""
    facts_db = {
        "climate change": {
            "key_facts": [
                "Global temperature has risen 1.1Â°C since pre-industrial times",
                "CO2 levels are at 420 ppm, highest in 800,000 years",
                "Sea levels rising 3.3mm per year",
            ],
            "sources": ["IPCC 2023", "NASA Climate", "NOAA"],
        },
        "artificial intelligence": {
            "key_facts": [
                "AI market expected to reach $1.8 trillion by 2030",
                "ChatGPT reached 100M users in 2 months",
                "Deep learning models double in size every 3.4 months",
            ],
            "sources": ["Gartner", "OpenAI", "Stanford AI Index"],
        },
        "renewable energy": {
            "key_facts": [
                "Solar costs dropped 89% since 2010",
                "Renewables now 30% of global electricity",
                "Wind power capacity grew 12% in 2023",
            ],
            "sources": ["IEA", "BloombergNEF", "IRENA"],
        },
    }
    topic_lower = topic.lower()
    for key in facts_db:
        if key in topic_lower:
            return facts_db[key]
    return {"key_facts": ["Topic requires further research"], "sources": []}


@tool
def analyze_data(data: str) -> dict:
    """Analyze data and extract insights."""
    return {
        "summary": f"Analysis of: {data[:50]}...",
        "sentiment": "neutral",
        "confidence": 0.85,
        "key_themes": ["technology", "innovation", "growth"],
    }


@tool
def format_report(content: str) -> str:
    """Format content into a professional report."""
    return f"""
=== REPORT ===
{content}

Generated by Open Agent Flow
==============
"""


@tool
def validate_content(text: str) -> dict:
    """Validate content for accuracy and quality."""
    return {
        "valid": True,
        "quality_score": 0.92,
        "suggestions": ["Add more specific data points"],
    }


# =============================================================================
# INDIVIDUAL AGENTS
# =============================================================================

@agent(model="mock", tools=[research_topic])
async def researcher(query: str) -> str:
    """Research agent - gathers facts on a topic."""
    pass


@agent(model="mock", tools=[analyze_data])
async def analyst(data: str) -> str:
    """Analyst agent - analyzes and extracts insights."""
    pass


@agent(model="mock", tools=[format_report])
async def writer(content: str) -> str:
    """Writer agent - formats content into reports."""
    pass


@agent(model="mock", tools=[validate_content])
async def reviewer(report: str) -> str:
    """Reviewer agent - validates and improves content."""
    pass


# Alternative analyst agents for swarm
@agent(model="mock", tools=[analyze_data])
async def analyst_optimist(data: str) -> str:
    """Optimistic analyst - sees opportunities."""
    pass


@agent(model="mock", tools=[analyze_data])
async def analyst_pessimist(data: str) -> str:
    """Pessimistic analyst - identifies risks."""
    pass


@agent(model="mock", tools=[analyze_data])
async def analyst_neutral(data: str) -> str:
    """Neutral analyst - balanced perspective."""
    pass


# =============================================================================
# CHAIN: Sequential Pipeline
# =============================================================================

@chain(agents=["researcher", "analyst", "writer"])
async def research_pipeline(topic: str) -> str:
    """
    Research Pipeline: Research -> Analyze -> Write

    Each agent's output feeds into the next agent.
    """
    pass


# =============================================================================
# SWARM: Parallel Consensus
# =============================================================================

@swarm(
    agents=["analyst_optimist", "analyst_pessimist", "analyst_neutral"],
    strategy="synthesis",
)
async def multi_perspective_analysis(data: str) -> str:
    """
    Multi-Perspective Analysis Swarm

    Three analysts examine the same data from different angles.
    Results are synthesized into a comprehensive view.
    """
    pass


@swarm(
    agents=["analyst_optimist", "analyst_pessimist", "analyst_neutral"],
    strategy="voting",
    min_agreement=0.5,
)
async def consensus_analysis(data: str) -> str:
    """
    Consensus Analysis Swarm

    Three analysts vote on the most important insight.
    """
    pass


# =============================================================================
# DEMO RUNNER
# =============================================================================

async def demo_individual_agent():
    """Demo: Single agent execution."""
    print("\n" + "=" * 70)
    print("DEMO 1: Individual Agent")
    print("=" * 70)

    print("\n[Agent]: researcher")
    print("[Task]: Research climate change")

    result = await researcher("Tell me about climate change")

    print(f"\n[Status]: {result.status.name}")
    print(f"[Output]: {result.output}")
    print(f"[Iterations]: {result.iterations}")
    print(f"[Duration]: {result.duration_ms:.1f}ms")

    if result.execution_hash:
        print(f"[Hash]: {result.execution_hash}")


async def demo_chain():
    """Demo: Chain execution (sequential pipeline)."""
    print("\n" + "=" * 70)
    print("DEMO 2: Chain (Sequential Pipeline)")
    print("=" * 70)

    print("\n[Chain]: research_pipeline")
    print("[Agents]: researcher -> analyst -> writer")
    print("[Input]: 'artificial intelligence trends'")

    result: ChainResult = await research_pipeline("artificial intelligence trends")

    print(f"\n[Status]: {result.status.name}")
    print(f"[Final Output]: {result.output}")
    print(f"[Agents Run]: {len(result.agent_results)}")
    print(f"[Total Tokens]: {result.total_tokens}")
    print(f"[Total Duration]: {result.duration_ms:.1f}ms")

    if result.execution_hash:
        print(f"[Chain Hash]: {result.execution_hash}")

    # Show each agent's contribution
    print("\n[Agent Results]:")
    for i, agent_result in enumerate(result.agent_results, 1):
        print(f"  {i}. {agent_result.agent_name}: {agent_result.status.name}")


async def demo_swarm_synthesis():
    """Demo: Swarm with synthesis strategy."""
    print("\n" + "=" * 70)
    print("DEMO 3: Swarm (Parallel + Synthesis)")
    print("=" * 70)

    print("\n[Swarm]: multi_perspective_analysis")
    print("[Strategy]: synthesis (combine all perspectives)")
    print("[Agents]: analyst_optimist, analyst_pessimist, analyst_neutral")
    print("[Input]: 'renewable energy market data'")

    result: SwarmResult = await multi_perspective_analysis("renewable energy market data")

    print(f"\n[Status]: {result.status.name}")
    print(f"[Consensus Method]: {result.consensus_method}")
    print(f"[Agreement Score]: {result.agreement_score:.1%}")
    print(f"[Agents Completed]: {len(result.agent_results)}")
    print(f"[Total Duration]: {result.duration_ms:.1f}ms")

    # Synthesis returns a list of all outputs
    if isinstance(result.output, list):
        print(f"\n[Synthesized Outputs]: {len(result.output)} perspectives")
        for i, output in enumerate(result.output, 1):
            preview = str(output)[:60] + "..." if len(str(output)) > 60 else output
            print(f"  {i}. {preview}")


async def demo_swarm_voting():
    """Demo: Swarm with voting strategy."""
    print("\n" + "=" * 70)
    print("DEMO 4: Swarm (Parallel + Voting)")
    print("=" * 70)

    print("\n[Swarm]: consensus_analysis")
    print("[Strategy]: voting (majority wins)")
    print("[Agents]: analyst_optimist, analyst_pessimist, analyst_neutral")
    print("[Input]: 'tech market outlook'")

    result: SwarmResult = await consensus_analysis("tech market outlook")

    print(f"\n[Status]: {result.status.name}")
    print(f"[Consensus Method]: {result.consensus_method}")
    print(f"[Agreement Score]: {result.agreement_score:.1%}")
    print(f"[Winning Output]: {result.output}")
    print(f"[Total Duration]: {result.duration_ms:.1f}ms")


async def demo_lineage_tracking():
    """Demo: Execution hash lineage."""
    print("\n" + "=" * 70)
    print("DEMO 5: Lineage Tracking")
    print("=" * 70)

    print("\n[Concept]: Each execution has a unique hash.")
    print("[Concept]: Child executions reference parent hashes.")
    print("[Concept]: This creates a traceable execution graph.")

    # First agent (root)
    result1 = await researcher("climate change")
    hash1 = result1.execution_hash.value if result1.execution_hash else "none"

    # Second agent with parent
    result2 = await analyst("climate analysis", parent_hash=hash1)
    hash2 = result2.execution_hash.value if result2.execution_hash else "none"

    # Chain with parent
    chain_result = await research_pipeline("AI trends", parent_hash=hash2)

    print(f"\n[Execution 1]: researcher")
    print(f"  Hash: {hash1[:16]}...")
    print(f"  Parents: (root)")

    print(f"\n[Execution 2]: analyst")
    print(f"  Hash: {hash2[:16]}...")
    if result2.execution_hash:
        print(f"  Parents: {result2.execution_hash.parents}")

    print(f"\n[Execution 3]: research_pipeline (chain)")
    if chain_result.execution_hash:
        print(f"  Hash: {chain_result.execution_hash.value[:16]}...")
        print(f"  Parents: {chain_result.execution_hash.parents}")


async def main():
    print("=" * 70)
    print("Open Agent Flow - Multi-Agent Demo")
    print("=" * 70)
    print("\nThis demo showcases:")
    print("  1. Individual agents with tools")
    print("  2. Chains - sequential agent pipelines")
    print("  3. Swarms - parallel execution with consensus")
    print("  4. Lineage tracking via execution hashes")
    print("\nNo API keys needed - using MockProvider!")

    await demo_individual_agent()
    await demo_chain()
    await demo_swarm_synthesis()
    await demo_swarm_voting()
    await demo_lineage_tracking()

    print("\n" + "=" * 70)
    print("Multi-Agent Demo Complete!")
    print("=" * 70)
    print("\nKey Takeaways:")
    print("  - @agent defines individual agents with tools")
    print("  - @chain creates sequential pipelines (output flows to next)")
    print("  - @swarm runs agents in parallel with consensus strategies")
    print("  - ExecutionHash tracks lineage for debugging & reproducibility")
    print("\nTo use real LLMs:")
    print("  export ANTHROPIC_API_KEY=your-key")
    print("=" * 70)


if __name__ == "__main__":
    asyncio.run(main())
